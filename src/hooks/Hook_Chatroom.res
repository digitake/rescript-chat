open Webapi
open React

type status =
  | Open(Js.Date.t)
  | Closed(Js.Date.t)
  | Closing
  | Connecting

type t = {
  sessionId: option<string>,
  messages: array<Data.ChatItem.t>,
  status: status,
  sendMessage: string => unit,
  close: unit => unit,
}


let useChatroom = (~autoReconnect=true, ~chatroomId) => {
  let target = `${Config.websocketBaseURL}/chatroom/${chatroomId}/`

  let socketRef = useRef(None)
  let me = AuthContext.useMyProfile()
  
  let (messages, setMessages) = useState(() => [])
  let (status, setStatus) = useState(() => Connecting)

  // This is the session id that the server will use to identify the client
  // Generated by the server and sent to the client on the first message
  let (sessionId, setSessionId) = useState(() => None)

  useEffect1(() => {
    Js.log2("session id changed", sessionId)

    None
  }, [sessionId])

  let onSocketOpen = (_socket) => {
    setStatus(_ => Open(Js.Date.make()))
  }

  let onSocketClose = () => {
    setStatus(_ => Closed(Js.Date.make()))
  }

  let handleUserEventMessage = (item) => {
    Js.log4("handleUserEvent", item, "session", sessionId)
  }

  let handleSystemMessage = (item:Data.ChatItem.t) => {
    Js.log2("handleSystem", item)
    switch (item.subtype, item.data) {
    | ("session", Text(id)) => {
        Js.log2("Setting session id", id)
        setSessionId(_=>Some(id))
      }
    | _ => ()
    }
  }

  let handleChatMessage = (item:Data.ChatItem.t) => {
    Js.log4("handleChat", item, "session", sessionId)
    let replacedSessionId = {
      ...item,
      sender: Some(Obj.magic(item.sender)) == sessionId ? me.id : item.sender
    }
    Js.log3(sessionId,"==?", item.sender)
    setMessages(oldMsg => oldMsg->Array.concat([replacedSessionId]))
  }

  let onSocketMessage = (_socket, event:WebSocket.messageEvent<Webapi__Blob.t>
 ) => {
    switch event.data {
    | String(rawJson) => {
        let json = Js.Json.parseExn(rawJson)
        let item = Data.ChatItem.Decode.item(json)

        switch item.msgType {
        | Chat => handleChatMessage(item)
        | UserEvent => handleUserEventMessage(item)
        | System => handleSystemMessage(item)
        | _ => ()
        }
      }
    | _ => Js.log("Received non-string message")
    }
  }

  let installListeners = socket => {
    socket->WebSocket.addOpenListener(_=> onSocketOpen(socket))
    socket->WebSocket.addMessageListener(evt => onSocketMessage(socket, evt))
    socket->WebSocket.addCloseListener(_=> onSocketClose())
  }

  let connect = url => {
    // The is very side-effect full. The connect method will ensure that the socket is open
    // If the socket is already open, it will do nothing and return the same socket
    // If the socket is not open, it will create a new socket and return it

    let _prepSocket = () => {
      let socket = Api.WebSocket.makeWithSubProtocol(url,["chatdoo-v1"])
      socketRef.current = Some(socket)
      installListeners(socket)
    }

    Js.log("Connecting to websocket...")
    // Create WebSocket connection.
    switch socketRef.current {
    | None => _prepSocket()
    | Some(s) if !(s->WebSocket.isOpen) => _prepSocket()
    | _ => Js.log("Socket already open")
    }
  }

  let sendMessage = msg => {
    switch socketRef.current {
    | Some(s) => {
        let newItem = (
          {
            sender: me.id,
            data: Text(msg),
            timestamp: Js.Date.make(),
            msgType: Chat,
            subtype: "",
          }: Data.ChatItem.t
        )
        setMessages(oldMsg => oldMsg->Array.concat([newItem]))
        s->WebSocket.sendText(Data.ChatItem.Encode.item(newItem)->Js.Json.stringify)
      }
    | None => Js.Exn.raiseError("Socket not connected")
    }
  }

  let close = () => {
    switch socketRef.current {
    | Some(s) => {
        Js.log("Closing websocket...")
        s->WebSocket.close
      }
    | _ => ()
    }
  }

  React.useEffect1(()=>{
    switch status {
    | Closed(_) => {
        if autoReconnect {
          let _ = setTimeout(() => {
            Js.log2("Reconnecting to websocket...", target)
            connect(target)
        }, 5000)
        }
      }
    | _ => ()
    }

    None
  }, [status])

  React.useEffect0(() => {
    connect(target)

    Some(close)
  })

  {sessionId, messages, status, sendMessage, close}
}
